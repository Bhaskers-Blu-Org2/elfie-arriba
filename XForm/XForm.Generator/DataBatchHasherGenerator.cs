using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace XForm.Generator
{
    public class DataBatchHasherGenerator
    {
        private static string FilePrefix = @"
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// GENERATED by XForm.Generator\DataBatchHasherGenerator.cs

using Microsoft.CodeAnalysis.Elfie.Model.Strings;
using System;
using XForm.Data;

namespace XForm
{
    
    internal class Rehasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException(""hashes.Length"");
            Array array = batch.Array;

            for (int i = 0; i<batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array.GetValue(batch.Index(i)).GetHashCode(), 0));
                }
            }
        }
    }

    public class DataBatchHasher
    {
        public static Action<DataBatch, uint[]> HasherForType(Type t)
        {
";

        private static string HasherForTypeTemplate = @"            if (t == typeof(long)) return LongHasher.Hash;
";

        private static string HasherForTypeSuffix = @"
            return Rehasher.Hash;
        }
    }
";


        private static string FileSuffix = @"
}
";

        // NOTE: Edit this in the 'Long' copy and then copy and paste the code here once tested
        private static string HasherTemplate = @"
	internal class LongHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException(""hashes.Length"");
            long[] array = (long[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }
";

        public static void Generate(string outputFilePath)
        {
            IEnumerable<string> types = SupportedTypes.PrimitiveTypes.Concat(SupportedTypes.AdditionalTypes);

            using (var writer = new StreamWriter(File.Open(outputFilePath, FileMode.Create)))
            {
                writer.Write(FilePrefix);

                foreach (string type in types)
                {
                    Generate(type, HasherForTypeTemplate, writer);
                }

                writer.Write(HasherForTypeSuffix);

                foreach (string type in types)
                {
                    Generate(type, HasherTemplate, writer);
                }

                writer.Write(FileSuffix);
            }
        }

        private static void Generate(string typeName, string template, StreamWriter writer)
        {
            string className = Char.ToUpperInvariant(typeName[0]) + typeName.Substring(1) + "Hasher";

            string hasherCode = template
                .Replace("long", typeName)
                .Replace("LongHasher", className);

            writer.Write(hasherCode);
        }
    }
}