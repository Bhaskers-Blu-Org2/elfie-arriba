
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// GENERATED by XForm.Generator\DataBatchHasherGenerator.cs

using Microsoft.CodeAnalysis.Elfie.Model.Strings;
using System;
using XForm.Data;

namespace XForm
{
    
    internal class Rehasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            Array array = batch.Array;

            for (int i = 0; i<batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array.GetValue(batch.Index(i)).GetHashCode(), 0));
                }
            }
        }
    }

    public class DataBatchHasher
    {
        public static Action<DataBatch, uint[]> HasherForType(Type t)
        {
            if (t == typeof(sbyte)) return SbyteHasher.Hash;            if (t == typeof(byte)) return ByteHasher.Hash;            if (t == typeof(short)) return ShortHasher.Hash;            if (t == typeof(ushort)) return UshortHasher.Hash;            if (t == typeof(int)) return IntHasher.Hash;            if (t == typeof(uint)) return UintHasher.Hash;            if (t == typeof(long)) return LongHasher.Hash;            if (t == typeof(ulong)) return UlongHasher.Hash;            if (t == typeof(float)) return FloatHasher.Hash;            if (t == typeof(double)) return DoubleHasher.Hash;            if (t == typeof(DateTime)) return DateTimeHasher.Hash;            if (t == typeof(TimeSpan)) return TimeSpanHasher.Hash;            if (t == typeof(Guid)) return GuidHasher.Hash;            if (t == typeof(String8)) return String8Hasher.Hash;
            return Rehasher.Hash;
        }
    }
	internal class SbyteHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            sbyte[] array = (sbyte[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class ByteHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            byte[] array = (byte[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class ShortHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            short[] array = (short[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class UshortHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            ushort[] array = (ushort[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class IntHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            int[] array = (int[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class UintHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            uint[] array = (uint[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class LongHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            long[] array = (long[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class UlongHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            ulong[] array = (ulong[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class FloatHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            float[] array = (float[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class DoubleHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            double[] array = (double[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class DateTimeHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            DateTime[] array = (DateTime[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class TimeSpanHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            TimeSpan[] array = (TimeSpan[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class GuidHasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            Guid[] array = (Guid[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

	internal class String8Hasher
    {
        public static void Hash(DataBatch batch, uint[] hashes)
        {
            if (hashes.Length < batch.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            String8[] array = (String8[])batch.Array;

            for (int i = 0; i < batch.Count; ++i)
            {
                int index = batch.Index(i);
                if (batch.IsNull == null || batch.IsNull[index] == false)
                {
                    hashes[i] ^= unchecked((uint) Hashing.Hash(array[batch.Index(i)], 0));
                }
            }
        }
    }

    }
}
